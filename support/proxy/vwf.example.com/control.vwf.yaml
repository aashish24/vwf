# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

## The component representation of a control behavior
## 
## @name control.vwf
## @namespace

---
properties:
  intermediateValue: 
    set: |
      this.intermediateValue = value;
      if("animationTime" in this && !this.animationPlaying) {
        if(this.positions.length > 1) {
          for(var i=0; i<(this.positions.length-1); i++) {
            if(this.intermediateValue > this.positions[i].controlValue && this.intermediateValue < this.positions[i+1].controlValue) {
              var animationRatio = (this.positions[i+1].animationTime - this.positions[i].animationTime) / (this.positions[i+1].controlValue - this.positions[i].controlValue);
              this.animationTime = this.intermediateValue * animationRatio;
              break;
            }
          }
        }
      }
    value: 0
  controlValue: 
    set: |
      this.controlValue = value;
      if(this.positions.length > 1) {
        if(this.controlValue > this.positions[this.positions.length-1].controlValue) {
          this.controlDirection = -1;
          this.controlValue = this.positions[this.positions.length-2].controlValue;
        }
        else if(this.controlValue < this.positions[0].controlValue) {
          this.controlDirection = 1;
          this.controlValue = this.positions[1].controlValue;
        }
      }
      if("animationTime" in this && !this.animationPlaying) {
        for(var i=0; i<this.positions.length; i++) {
          if(this.controlValue == this.positions[i].controlValue) {
            this.animationTime = this.positions[i].animationTime;
          }
        }
      }
      this.controlValueUpdated();
    value: 0
  controlScale: 1
  controlDirection: 
    set: |
      if(!this.playing) {
        switch(value) {
          case 1:
          case -1:
            this.direction = value;
            break;
        }
      }
    value: 1
methods:
  mouseInit: 
events:
  controlValueUpdated:
  pointerDown:
  pointerMove:
  pointerUp:
scripts:
- |
  this.initialize = function() {
    
    // Locate child nodes that extend or implement "http://vwf.example.com/control/position.vwf"
    // to identify themselves as control key positions.

    this.positions = this.find( "./element(*,'http://vwf.example.com/control/position.vwf')" );

    // Fill in missing `controlValue` properties, distributing evenly between the left and right
    // positions that define `controlValue`.

    // 1: [ - ] => [ 0 ]
    // 1: [ 0, - ] => [ 0, 1 ]
    // 1: [ -, 1 ] => [ 0, 1 ]
    // 1: [ 0, -, - ] => [ 0, 1/2, 1 ]
    // 1: [ -, -, 1 ] => [ 0, 1/2, 1 ]
    // 1: [ 0, - , -, 1 ] => [ 0, 1/3 , 2/3, 1 ]

    var leftValue, leftIndex;
    var rightValue, rightIndex = -Infinity;

    if ( this.positions.length > 0 ) {

      this.positions.sort(function(a, b) {
        return a.sequence - b.sequence;
      });
      
      if ( this.positions[0].controlValue === null ) {
        this.positions[0].controlValue = 0;
      }

      if ( this.positions[this.positions.length-1].controlValue === null ) {
        this.positions[this.positions.length-1].controlValue = 1;
      }

      this.positions.forEach( function( position, index ) {

        if ( position.controlValue !== null ) {

          leftValue = position.controlValue;
          leftIndex = index;

        } else {

          if ( index > rightIndex ) {
            for ( rightIndex = index + 1; rightIndex < this.positions.length; rightIndex++ ) {
              if ( ( rightValue = /* assignment! */ this.positions[rightIndex].controlValue ) !== null ) {
                break;
              }
            }
          }

          position.controlValue = leftValue + ( rightValue - leftValue ) *
            ( index - leftIndex )  / ( rightIndex - leftIndex );

        }

        this.logger.info( "control position", position.name, position.controlValue );

      }, this );

    }

  } //@ sourceURL=http://vwf.example.com/control.vwf/scripts~initialize

  // Sets up the mouse pointer information used for dragging.
  this.mouseInit = function() {
    this.input = {
      "pointerInfo": undefined,
      "pickInfo": undefined,
      "previous": {
        "pointerInfo": undefined,
        "pickInfo": undefined,        
      },
      update: function( pointerInfo, pickInfo ){
        if(!this.previous.pointerInfo) {
          this.previous.pointerInfo = this.pointerInfo;
          this.previous.pickInfo = this.pickInfo;
        }
        this.pointerInfo = pointerInfo;
        this.pickInfo = pickInfo;
      }, 
      clear: function(){
        this.previous.pointerInfo = undefined;
        this.previous.pickInfo = undefined;
        this.pointerInfo = undefined;
        this.pickInfo = undefined;        
      },
      change: function() {
        var ret = [ 0, 0 ]
        if ( this.pointerInfo && this.previous.pointerInfo ) {
          ret[0] = this.pointerInfo.position[0] - this.previous.pointerInfo.position[0];
          ret[1] = this.pointerInfo.position[1] - this.previous.pointerInfo.position[1];
        }
        return ret;
      }
    };
  }

  this.pointerDown = function( pointerInfo, pickInfo ) {
    if ( !this.input ) this.mouseInit();
    this.input.clear();
    this.input.pointerInfo = pointerInfo;
    this.input.pickInfo = pickInfo;
    this.intermediateValue = this.controlValue;
    this.positions = this.find( "./element(*,'http://vwf.example.com/control/position.vwf')" );
    this.positions.sort(function(a, b) {
      return a.sequence - b.sequence;
    });
  }

  this.pointerUp = function( pointerInfo, pickInfo ) {
    for(var i=0; i<this.positions.length; i++) {
      if(this.input.previous.pointerInfo == undefined) {
        if(this.controlValue == this.positions[i].controlValue) {
          if(!((i + this.controlDirection) >= 0 && (i + this.controlDirection) < this.positions.length)) {
            this.controlDirection = this.controlDirection * -1;
          }
          // TODO Should animate to the next position
          this.controlValue = this.positions[i + this.controlDirection].controlValue;
          break;
        }
        else if(i+1 < this.positions.length && this.intermediateValue > this.positions[i].controlValue && this.intermediateValue < this.positions[i+1].controlValue) {
          if(this.controlDirection) {
            this.controlValue = this.positions[i+1].controlValue;
          }
          else {
            this.controlValue = this.positions[i].controlValue;
          }
        }
      }
      else {
        if(this.intermediateValue == this.positions[i].controlValue) {
          this.controlValue = this.positions[i].controlValue;
          break;
        }
        else if(i+1 < this.positions.length && this.intermediateValue > this.positions[i].controlValue && this.intermediateValue < this.positions[i+1].controlValue) {
          var nearPosition, farPosition;
          if((this.positions[i].controlValue - this.intermediateValue) >= (this.positions[i+1].controlValue - this.intermediateValue)) {
            nearPosition = this.positions[i];
            farPosition = this.positions[i+1];
          }
          else {
            nearPosition = this.positions[i+1];
            farPosition = this.positions[i];
          }
          switch(nearPosition.controlType) {
            case 1:
              this.controlValue = nearPosition.controlValue;
              break;
            case -1:
              // TODO How does this work?
            case 0:
              this.controlValue = this.intermediateValue;
              break;
          }
          break;
        }
      }
    }
    this.input.clear();
  }

  this.pointerMove = function( pointerInfo, pickInfo ) {
    var minValue = this.positions[0].controlValue;
    var maxValue = this.positions[this.positions.length-1].controlValue;
    this.input.update( pointerInfo, pickInfo );
    var diff = this.input.change();
    if(Math.abs(diff[0]) >= Math.abs(diff[1])) {
      var changeBy = diff[0] * this.controlScale;
      if(diff[0] > 0 && this.intermediateValue < maxValue) {
        this.controlDirection = 1;
        if((this.intermediateValue + changeBy) < maxValue) {
          this.intermediateValue = this.intermediateValue + changeBy;
        }
      }
      else if(diff[0] < 0 && this.intermediateValue > minValue) {
        this.controlDirection = -1;
        if((this.intermediateValue + changeBy) > minValue) {
          this.intermediateValue = this.intermediateValue + changeBy;
        }
      }
    }
    else {
      var changeBy = diff[1] * this.controlScale;
      if(diff[1] > 0 && this.intermediateValue < maxValue) {
        this.controlDirection = 1;
        if((this.intermediateValue + changeBy) < maxValue) {
          this.intermediateValue = this.intermediateValue + changeBy;
        }
      }
      else if(diff[1] < 0 && this.intermediateValue > minValue) {
        this.controlDirection = -1;
        if((this.intermediateValue + changeBy) > minValue) {
          this.intermediateValue = this.intermediateValue + changeBy;
        }
      }
    }
    this.input.previous.pointerInfo = pointerInfo;
    this.input.previous.pickInfo = pickInfo;
  }
