# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

## The component representation of a control behavior
## 
## @name control.vwf
## @namespace

---
properties:
  intermediateValue: 
    set: |
      this.intermediateValue = value;
      if("animationTime" in this && !this.animationPlaying) {
        if(this.positions.length > 1) {
          for(var i=0; i<(this.positions.length-1); i++) {
            if(this.intermediateValue > this.positions[i].controlValue && this.intermediateValue < this.positions[i+1].controlValue) {
              var animationRatio = (this.positions[i+1].animationTime - this.positions[i].animationTime) / (this.positions[i+1].controlValue - this.positions[i].controlValue);
              this.animationTime = this.intermediateValue * animationRatio;
              break;
            }
          }
        }
      }
    value: 0
  controlValue: 
    set: |
      if(this.positions.length > 1) {
        if(value > this.positions[this.positions.length-1].controlValue) {
          this.controlDirection = -1;
          value = this.positions[this.positions.length-2].controlValue;
        }
        else if(value < this.positions[0].controlValue) {
          this.controlDirection = 1;
          value = this.positions[1].controlValue;
        }
      }
      if("animationTime" in this && !this.animationPlaying) {
        for(var i=0; i<this.positions.length; i++) {
          if(value == this.positions[i].controlValue) {
            this.animationTime = this.positions[i].animationTime;
          }
        }
      }
      if(value !== this.controlValue) {
        this.controlValue = value;
        this.controlValueUpdated();
      }
    value: 0
  controlScale: 1
  controlDirection: 
    set: |
      switch(value) {
        case 1:
        case -1:
          this.direction = value;
          break;
      }
    value: 1
  controlPlaying: false
  controlMomentary: false
methods:
  mouseInit: 
  controlTick:
events:
  controlValueUpdated:
  pointerDown:
  pointerMove:
  pointerUp:
scripts:
- |
  this.initialize = function() {
    
    // Locate child nodes that extend or implement "http://vwf.example.com/control/position.vwf"
    // to identify themselves as control key positions.

    this.positions = this.find( "./element(*,'http://vwf.example.com/control/position.vwf')" );

    // Fill in missing `controlValue` properties, distributing evenly between the left and right
    // positions that define `controlValue`.

    // 1: [ - ] => [ 0 ]
    // 1: [ 0, - ] => [ 0, 1 ]
    // 1: [ -, 1 ] => [ 0, 1 ]
    // 1: [ 0, -, - ] => [ 0, 1/2, 1 ]
    // 1: [ -, -, 1 ] => [ 0, 1/2, 1 ]
    // 1: [ 0, - , -, 1 ] => [ 0, 1/3 , 2/3, 1 ]

    var leftValue, leftIndex;
    var rightValue, rightIndex = -Infinity;

    if ( this.positions.length > 0 ) {

      this.positions.sort(function(a, b) {
        return a.sequence - b.sequence;
      });
      
      if ( this.positions[0].controlValue === null ) {
        this.positions[0].controlValue = 0;
      }

      if ( this.positions[this.positions.length-1].controlValue === null ) {
        this.positions[this.positions.length-1].controlValue = 1;
      }

      this.positions.forEach( function( position, index ) {

        if ( position.controlValue !== null ) {

          leftValue = position.controlValue;
          leftIndex = index;

        } else {

          if ( index > rightIndex ) {
            for ( rightIndex = index + 1; rightIndex < this.positions.length; rightIndex++ ) {
              if ( ( rightValue = /* assignment! */ this.positions[rightIndex].controlValue ) !== null ) {
                break;
              }
            }
          }

          position.controlValue = leftValue + ( rightValue - leftValue ) *
            ( index - leftIndex )  / ( rightIndex - leftIndex );

        }

        this.logger.info( "control position", position.name, position.controlValue );

      }, this );

    }

  } //@ sourceURL=http://vwf.example.com/control.vwf/scripts~initialize

  // Sets up the mouse pointer information used for dragging.
  this.mouseInit = function() {
    this.input = {
      "pointerInfo": undefined,
      "pickInfo": undefined,
      "previous": {
        "pointerInfo": undefined,
        "pickInfo": undefined,        
      },
      update: function( pointerInfo, pickInfo ){
        if(!this.previous.pointerInfo) {
          this.previous.pointerInfo = this.pointerInfo;
          this.previous.pickInfo = this.pickInfo;
        }
        this.pointerInfo = pointerInfo;
        this.pickInfo = pickInfo;
      }, 
      clear: function(){
        this.previous.pointerInfo = undefined;
        this.previous.pickInfo = undefined;
        this.pointerInfo = undefined;
        this.pickInfo = undefined;        
      },
      change: function() {
        var ret = [ 0, 0 ]
        if ( this.pointerInfo && this.previous.pointerInfo ) {
          ret[0] = this.pointerInfo.position[0] - this.previous.pointerInfo.position[0];
          ret[1] = this.pointerInfo.position[1] - this.previous.pointerInfo.position[1];
        }
        return ret;
      }
    };
  }
  
  this.pointerDown = function( pointerInfo, pickInfo ) {
    if ( !this.input ) this.mouseInit();
    this.input.clear();
    this.input.pointerInfo = pointerInfo;
    this.input.pickInfo = pickInfo;
    this.positions = this.find( "./element(*,'http://vwf.example.com/control/position.vwf')" );
    this.positions.sort(function(a, b) {
      return a.sequence - b.sequence;
    });
    if(this.controlMomentary) {
      this.controlPlaying = true;
      this.controlDirection = 1;
      this.controlTick(this.positions[this.positions.length-1]);
    }
    else {
      this.intermediateValue = this.controlValue;
    }
  }

  this.pointerUp = function( pointerInfo, pickInfo ) {
    if(this.controlMomentary) {
      this.controlPlaying = true;
      this.controlDirection = -1;
      this.controlTick(this.positions[0]);
    }
    else {
      for(var i=0; i<this.positions.length; i++) {
        if(this.input.previous.pointerInfo == undefined) {
          if(this.controlValue == this.positions[i].controlValue) {
            if(!((i + this.controlDirection) >= 0 && (i + this.controlDirection) < this.positions.length)) {
              this.controlDirection = this.controlDirection * -1;
            }
            this.controlPlaying = true;
            this.controlTick(this.positions[i + this.controlDirection]);
            break;
          }
          else if(i+1 < this.positions.length && this.intermediateValue > this.positions[i].controlValue && this.intermediateValue < this.positions[i+1].controlValue) {
            if(this.controlDirection == 1) {
              this.controlPlaying = true;
              this.controlTick(this.positions[i + 1]);
            }
            else {
              this.controlPlaying = true;
              this.controlTick(this.positions[i]);
            }
          }
        }
        else {
          if(this.intermediateValue == this.positions[i].controlValue) {
            this.controlValue = this.positions[i].controlValue;
          }
          else if(i+1 < this.positions.length && this.intermediateValue > this.positions[i].controlValue && this.intermediateValue < this.positions[i+1].controlValue) {
            var nearPosition, farPosition;
            if(Math.abs((this.positions[i].controlValue - this.intermediateValue)) < Math.abs((this.positions[i+1].controlValue - this.intermediateValue))) {
              nearPosition = this.positions[i];
              farPosition = this.positions[i+1];
            }
            else {
              nearPosition = this.positions[i+1];
              farPosition = this.positions[i];
            }
            switch(nearPosition.controlType) {
              case 1:
                this.controlPlaying = true;
                this.controlDirection = this.intermediateValue < nearPosition.controlValue ? 1 : -1;
                this.controlTick(nearPosition);
                break;
              case -1:
                if(this.farPosition.controlType != -1) {
                  this.controlPlaying = true;
                  this.conthis.controlDirection = this.intermediateValue < farPosition.controlValue ? 1 : -1;
                  this.controlTick(farPosition);
                }
                else {
                  this.controlValue = this.intermediateValue;
                }
              case 0:
                this.controlValue = this.intermediateValue;
                break;
            }
            break;
          }
        }
      }
    }
    this.input.clear();
  }

  this.pointerMove = function( pointerInfo, pickInfo ) {
    if(!this.controlMomentary) {
      var minValue = this.positions[0].controlValue;
      var maxValue = this.positions[this.positions.length-1].controlValue;
      this.input.update( pointerInfo, pickInfo );
      var diff = this.input.change();
      if(Math.abs(diff[0]) >= Math.abs(diff[1])) {
        var changeBy = diff[0] * this.controlScale;
        if(diff[0] > 0 && this.intermediateValue < maxValue) {
          this.controlDirection = 1;
          if((this.intermediateValue + changeBy) < maxValue) {
            this.intermediateValue = this.intermediateValue + changeBy;
          }
        }
        else if(diff[0] < 0 && this.intermediateValue > minValue) {
          this.controlDirection = -1;
          if((this.intermediateValue + changeBy) > minValue) {
            this.intermediateValue = this.intermediateValue + changeBy;
          }
        }
      }
      else {
        var changeBy = diff[1] * this.controlScale;
        if(diff[1] > 0 && this.intermediateValue < maxValue) {
          this.controlDirection = 1;
          if((this.intermediateValue + changeBy) < maxValue) {
            this.intermediateValue = this.intermediateValue + changeBy;
          }
        }
        else if(diff[1] < 0 && this.intermediateValue > minValue) {
          this.controlDirection = -1;
          if((this.intermediateValue + changeBy) > minValue) {
            this.intermediateValue = this.intermediateValue + changeBy;
          }
        }
      }
      this.input.previous.pointerInfo = pointerInfo;
      this.input.previous.pickInfo = pickInfo;
    }
  }

  this.controlTick = function (nextPosition) {
    if ( this.controlPlaying ) {
      if ( Math.abs(this.animationTime - nextPosition.animationTime) < goog.vec.EPSILON ) {
        this.controlValue = nextPosition.controlValue;
        this.controlPlaying = false;
      }
      // Schedule the next tick if still playing.
      if ( this.controlPlaying ) {
        if ( Math.abs(nextPosition.animationTime - this.animationTime) > 1/60 ) {
          this.animationTime = this.animationTime + (1/60 * this.controlDirection * this.animationRate);
          this.in( 1/60 ).controlTick(nextPosition); // next interval
        } else {
          this.animationTime = nextPosition.animationTime;
          this.at( Math.abs(nextPosition.animationTime - this.animationTime) ).controlTick(nextPosition); // exactly at end
        }
      }
    }
  }
